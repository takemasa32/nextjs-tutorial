# v1.0-initial: 実装詳細ガイド

## コードレビューポイント

### 1. 従来型のアーキテクチャ分析

#### API Routes 実装

ファイル: `src/app/api/notes/create/route.ts`

```typescript
// 特徴: RESTful API エンドポイント
export async function POST(request: Request) {
  // JSONペイロードの解析
  const { content }: CreateNoteRequest = await request.json();

  // サーバーサイドSupabaseクライアント使用
  const supabase = createServerComponentClient();

  // データベース操作
  const { data, error } = await supabase
    .from("notes")
    .insert({ content: content.trim() })
    .select()
    .single();
}
```

**問題点**:

- クライアント-サーバー間のデータ同期が複雑
- エラーハンドリングが分散
- 型の重複定義

#### Client Component での fetch 実装

ファイル: `src/app/page.tsx`

```typescript
// 手動のローディング状態管理
const [isLoading, setIsLoading] = useState(false);

const handleSubmit = async (e: FormEvent) => {
  e.preventDefault();
  setIsLoading(true);

  try {
    const response = await fetch("/api/notes/create", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to create note");
    }

    setContent("");
    fetchNotes(); // 手動でデータ再取得
  } catch (error) {
    setError(error instanceof Error ? error.message : "An error occurred");
  } finally {
    setIsLoading(false);
  }
};
```

**問題点**:

- 手動の状態管理が煩雑
- データの同期タイミングが不明確
- エラー処理の重複

### 2. 型システムの課題

#### 個別型定義の問題

ファイル: `src/types/note.ts`

```typescript
export interface Note {
  id: string;
  content: string;
  created_at: string;
}

export interface CreateNoteRequest {
  content: string;
}

export interface CreateNoteResponse {
  success: boolean;
  data?: Note;
  error?: string;
}
```

**問題点**:

- データベーススキーマとの不整合リスク
- 型の重複定義
- メンテナンス時の更新漏れ

### 3. テスト戦略

#### 単体テスト（API Route）

ファイル: `src/app/api/notes/create/route.test.ts`

```typescript
describe("/api/notes/create", () => {
  it("should create a note successfully", async () => {
    // Supabaseクライアントのモック
    (createServerComponentClient as jest.Mock).mockReturnValue({
      from: jest.fn().mockReturnValue({
        insert: jest.fn().mockReturnValue({
          select: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: mockNote,
              error: null,
            }),
          }),
        }),
      }),
    });

    const response = await POST(mockRequest);
    const result = await response.json();

    expect(response.status).toBe(200);
    expect(result.success).toBe(true);
  });
});
```

#### E2E テスト

ファイル: `tests/note.spec.ts`

```typescript
test("should create a new note", async ({ page }) => {
  await page.goto("/");

  // フォーム入力
  await page.fill(
    'input[placeholder="Enter your note content..."]',
    "New Note"
  );
  await page.click('button:has-text("Add Note")');

  // 結果の確認
  await expect(page.getByText("New Note")).toBeVisible();
});
```

## 次フェーズへの移行ポイント

### v2.0-action-created で解決される問題

1. **データ同期の簡素化**: Server Actions による自動 revalidation
2. **エラーハンドリングの統一**: サーバーサイドでの一元化
3. **型安全性の向上**: Supabase 由来の型システム

### 学習者が実装すべき課題

1. **コードレビュー**: 現在の実装の問題点を特定
2. **テスト実行**: 現在のテストを実行して動作確認
3. **次フェーズの準備**: Server Actions の概念理解
