# v2.0-action-created: Server Actions導入ガイド

## 概要

このフェーズでは、既存のAPI Routes実装を残したまま、新しいServer Actionsによるデータ更新ロジックを並行して実装します。これにより、2つのアプローチを比較学習できます。

## 学習目標

- Server Actionsの基本概念理解
- `'use server'`ディレクティブの使用法
- `revalidatePath`による自動データ更新
- `redirect`によるナビゲーション
- 既存システムとの共存方法

---

## 実装手順

### 1. Server Actions ファイルの作成

新しいファイルを作成: `src/app/notes/_actions.ts`

```typescript
'use server'

import { createServerComponentClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

export async function createNote(formData: FormData) {
  const content = formData.get('content') as string
  
  // バリデーション
  if (!content?.trim()) {
    throw new Error('Content is required')
  }

  // データベース操作
  const supabase = createServerComponentClient()
  const { error } = await supabase
    .from('notes')
    .insert({ content: content.trim() })

  if (error) {
    console.error('Supabase error:', error)
    throw new Error('Failed to create note')
  }

  // キャッシュ無効化とリダイレクト
  revalidatePath('/')
  redirect('/')
}
```

### 2. 重要なポイント解説

#### 2.1 `'use server'` ディレクティブ
```typescript
'use server' // ファイルの先頭に必須
```
- ファイル全体をServer Actionsとして定義
- サーバーサイドでのみ実行される
- クライアントサイドには関数名のみ送信

#### 2.2 FormDataの使用
```typescript
export async function createNote(formData: FormData) {
  const content = formData.get('content') as string
```
- HTMLネイティブのフォームデータを使用
- 型安全性は手動で保証が必要
- 将来的にはzodなどでバリデーション強化可能

#### 2.3 サーバーサイドSupabaseクライアント
```typescript
const supabase = createServerComponentClient()
```
- サーバーサイド専用のクライアント使用
- 環境変数`SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`を使用
- より強力な権限でデータベース操作可能

#### 2.4 自動データ更新
```typescript
revalidatePath('/')
```
- Next.jsのキャッシュを無効化
- 手動でのデータ再取得不要
- ユーザーには自動で最新データが表示

#### 2.5 サーバーサイドリダイレクト
```typescript
redirect('/')
```
- サーバーサイドでのナビゲーション
- クライアントサイドのルーター不要
- より効率的なページ遷移

---

## 従来実装との比較

### Before (v1.0): API Routes + fetch
```typescript
// クライアントサイド
const handleSubmit = async (e: FormEvent) => {
  e.preventDefault()
  setIsLoading(true)
  
  try {
    const response = await fetch('/api/notes/create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    })
    
    if (!response.ok) {
      throw new Error('Failed to create note')
    }
    
    setContent('')
    fetchNotes() // 手動でデータ再取得
  } catch (error) {
    setError(error.message)
  } finally {
    setIsLoading(false)
  }
}
```

### After (v2.0): Server Actions
```typescript
// サーバーサイド
'use server'

export async function createNote(formData: FormData) {
  const content = formData.get('content') as string
  
  if (!content?.trim()) {
    throw new Error('Content is required')
  }

  const supabase = createServerComponentClient()
  const { error } = await supabase
    .from('notes')
    .insert({ content: content.trim() })

  if (error) {
    throw new Error('Failed to create note')
  }

  revalidatePath('/') // 自動データ更新
  redirect('/')      // 自動リダイレクト
}
```

---

## 利点の分析

### 1. 簡潔性
- クライアントサイドのstate管理が不要
- エラーハンドリングの簡素化
- ローディング状態の自動管理

### 2. 型安全性の向上
- データベース型を直接利用可能
- APIエンドポイントの型定義不要
- TypeScriptの恩恵をフルに活用

### 3. パフォーマンス
- サーバーサイドでの直接実行
- 不要なJSONシリアライゼーション回避
- 効率的なデータ転送

### 4. セキュリティ
- サーバーサイド実行によるデータ保護
- 機密情報のクライアント露出回避
- より強力な認証・認可実装可能

---

## テスト戦略

### Server Actionsのテスト
新しいファイル: `src/app/notes/_actions.test.ts`

```typescript
import { createNote } from './_actions'
import { createServerComponentClient } from '@/lib/supabase/server'

// モック設定
jest.mock('@/lib/supabase/server')
jest.mock('next/cache')
jest.mock('next/navigation')

describe('Server Actions', () => {
  it('should create a note successfully', async () => {
    const mockSupabase = {
      from: jest.fn().mockReturnValue({
        insert: jest.fn().mockResolvedValue({ error: null })
      })
    }
    
    ;(createServerComponentClient as jest.Mock).mockReturnValue(mockSupabase)
    
    const formData = new FormData()
    formData.append('content', 'Test note content')
    
    await expect(createNote(formData)).resolves.not.toThrow()
  })
})
```

---

## 実習課題

### 基礎課題
1. **Server Actionsファイルの作成**: 上記の実装を正確に写す
2. **動作確認**: まだUIは変更せず、ファイルが正しく動作することを確認
3. **テストの実装**: Server Actionsのユニットテストを作成

### 発展課題  
1. **エラーハンドリングの拡張**: より詳細なエラーメッセージの実装
2. **バリデーション強化**: zod等を使った型安全なバリデーション
3. **ログ記録**: サーバーサイドでの操作ログ実装

### 理解度チェック
- [ ] `'use server'`の役割を説明できる
- [ ] `revalidatePath`の動作を理解している  
- [ ] FormDataの使用方法を理解している
- [ ] 従来方式との違いを説明できる

---

## 次フェーズへの準備

v3.0では、UIをServer Actionsに接続して、実際にユーザーが新しい実装を使用できるようにします。その際に重要となるポイント：

1. **フォーム属性の変更**: `onSubmit` → `action`
2. **プログレッシブエンハンスメント**: JavaScriptなしでも動作
3. **ユーザー体験**: ローディング状態の自然な表現

このフェーズでは**既存UIは一切変更しない**ことが重要です。新しいロジックを安全に実装し、次フェーズで段階的に移行していきます。
